## 第二章：线性表
### 线性表的逻辑结构
* 定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表
* 特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。
除第一个元素外，每个元素有且仅有一个直接前驱。
除最后一个元素外，每个元素有且仅有一个直接后继。
### 线性表的顺序存储结构
* 线性表的顺序存储又称为顺序表。
它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻
辑上相邻的两个元素在物理位置上也相邻。
* 建立顺序表的三个属性: 
1.存储空间的起始位置（数组名data）
2.顺序表最大存储容量（MaxSize）
3.顺序表当前的长度（length）
* 其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配
* 总结：
    * 1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。
    * 2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）
    * 3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。
### 顺序表的操作
* 1.插入
    * 算法思路：
        * 1.判断i的值是否正确
        * 2.判断表长是否超过数组长度
        * 3.从后向前到第i个位置，分别将这些元素都向后移动一位
        * 4.将该元素插入位置i 并修改表长
    * 代码
    * 分析：
        * 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。
        * 最坏情况：在表头插入（即i=1），元素后移语句将执行
n次，时间复杂度为O(n)。
        * 平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入
一个结点的概率，则在长度为n的线性表中插入一个结
点时所需移动结点的平均次数为
* 2.删除
    * 算法思路：
        * 1.判断i的值是否正确
        * 2.取删除的元素
        * 3.将被删元素后面的所有元素都依次向前移动一位
        * 4.修改表长
    * 代码
    * 分析
        * 最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。
        * 最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。
        * 平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为
### 线性表的链式存储结构
* 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。
* 头结点和头指针的区别？
    * 不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息
* 为什么要设置头结点？
    * 1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了
    * 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。
### 单链表的操作
* 1.头插法建立单链表：
    * 建立新的结点分配内存空间，将新结点插入到当前链表的表头
    * 代码
* 2.尾插法建立单链表：
    * 建立新的结点分配内存空间，将新结点插入到当前链表的表尾
    * 代码
* 3.按序号查找结点
    * 在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。
    * 代码
* 4.按值查找结点
    * 从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。
    * 代码
* 5．插入
    * 插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。
    * 算法思路：
1.取指向插入位置的前驱结点的指针
① p=GetElem(L,i-1);
2.令新结点*s的指针域指向*p的后继结点
② s->next=p->next;
3.令结点*p的指针域指向新插入的结点*s
③ p->next=s; 
* 6．删除
    * 删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。
    * 算法思路：
1.取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);
2.取指向删除位置的指针 q=p->next;
3.p指向结点的后继指向被删除结点的后继 p->next=q->next
4.释放删除结点 free(q);
### 双链表
* 定义
* 1.插入：(方法不唯一)
① s->next=p->next;
② p->next->prior=s;
③ s->prior=p;
④ p->next=s;
* 2.删除：
① p->next=q->next;
② q->next->prior=p;
③ free(q);

### 循环链表&&静态链表
* 循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环
* 循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环
    * 当循环双链表为空表时，其头结点的prior域和next域都等于Head。
* 静态链表：静态链表是用数组来描述线性表的链式存储结构。
    * 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。
    * 例子
## 第三章：栈和队列
### 栈
* 栈（Stack）：只允许在一端进行插入或删除操作的线性表。
* 栈顶（Top）：线性表允许进行插入和删除的那一端。
* 栈底（Bottom）：固定的，不允许进行插入和删除的另一端
* 特点：
1.栈是受限的线性表，所以自然具有线性关
系。
2.栈中元素后进去的必然先出来，即后进先出
LIFO（Last In First Out）
    * 栈中元素后进
去的必然先出
来，即后进先
出LIFO（Last In
First Out）
* 顺序栈
    * 栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。
    * 顺序栈的操作
        * 1.判空：
        * 2.进栈：
        * 3.出栈：
        * 4.读取栈顶元素：
* 共享栈
    * 顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享
    * 示意图
    * 共享栈的结构
    * 共享栈的操作：（进栈）
* 链式栈
    * 栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。
    * 特点
1.链栈一般不存在栈满的情况。
2.空栈的判定条件通常定为top==NULL；
    * 结构
    * 链式栈的操作
        * 1.进栈
        * 2.出栈
### 队列
* 队列是只允许在一端进行插入，而在另一端进行删除的线性表
* 队头（Front）：允许删除的一端，又称为队首。
* 队尾（Rear）： 允许插入的一端。
* 先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO
* 顺序队列
    * 用数组来实现队列，可以将队首放在数组下标为0的位置。
* 循环队列
    * 把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列
    * 入队：rear=(rear+1)%MaxSize
    * 出队：front=(front+1)%MaxSize
    * 循环队列的操作
        * 1.入队：
        * 2.出队：
    * 概要: 那如何分辨队列是空还是满呢？
        * 方法一：设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满。
        * 方法二：我们把front=rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。
* 链式队列
    * 队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。
    * 为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。
    * 链式队列的操作
        * 1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。

        * 2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。
* 双端队列
    * 双端队列是指允许两端都可以进行入队和出队操作的队列
### 栈的应用
* 1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。
    * 算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。

    * 代码
* 2、表达式求值：
    *  
    * 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。
* 3、递归：
    * 要理解递归，你要先理解递归，直到你能理解递归。
如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。
    * 1.阶乘
        * 时间复杂度：O(NlogN)
    * 2.斐波那契数列
        * 时间复杂度   O(2^n)
* 概要: 如何将中缀表达式转换成后缀表达式？
    * 1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)
    * 2.把运算符移到对应的括号后。
    * 3.去掉括号。
    * 例子
